# Final LLBC before serialization:

struct test_crate::Struct<A> =
{
  A
}

trait core::default::Default<Self>
{
    fn default : core::default::Default::default
}

fn core::default::Default::default<Self>() -> Self

fn test_crate::{impl core::default::Default for test_crate::Struct<A>#1}::default<A>() -> test_crate::Struct<A>
where
    // Inherited clauses:
    [@TraitClause0]: core::default::Default<A>,
{
    let @0: test_crate::Struct<A>; // return
    let @1: A; // anonymous local

    @1 := @TraitClause0::default()
    @0 := test_crate::Struct { 0: move (@1) }
    drop @1
    drop @1
    return
}

impl<A> test_crate::{impl core::default::Default for test_crate::Struct<A>#1}<A> : core::default::Default<test_crate::Struct<A>>
where
    [@TraitClause0]: core::default::Default<A>,
{
    fn default = test_crate::{impl core::default::Default for test_crate::Struct<A>#1}::default
}

trait test_crate::Trait<Self, B>
{
    type Item
    fn method : test_crate::Trait::method
}

trait core::clone::Clone<Self>
{
    fn clone : core::clone::Clone::clone
    fn clone_from
}

trait core::cmp::PartialEq<Self, Rhs>
{
    fn eq : core::cmp::PartialEq::eq
    fn ne
}

fn test_crate::{impl test_crate::Trait<B> for test_crate::Struct<A>}::method<A, B, C>()
where
    // Inherited clauses:
    [@TraitClause0]: core::clone::Clone<A>,
    [@TraitClause1]: core::cmp::PartialEq<B, bool>,
{
    let @0: (); // return
    let @1: (); // anonymous local

    @1 := ()
    @0 := move (@1)
    @0 := ()
    return
}

impl<A, B> test_crate::{impl test_crate::Trait<B> for test_crate::Struct<A>}<A, B> : test_crate::Trait<test_crate::Struct<A>, B>
where
    [@TraitClause0]: core::clone::Clone<A>,
    [@TraitClause1]: core::cmp::PartialEq<B, bool>,
{
    type Item = (A, B) with []
    fn method = test_crate::{impl test_crate::Trait<B> for test_crate::Struct<A>}::method
}

fn core::default::{impl core::default::Default for bool#1}::default() -> bool

impl core::default::{impl core::default::Default for bool#1} : core::default::Default<bool>
{
    fn default = core::default::{impl core::default::Default for bool#1}::default
}

opaque type alloc::string::String

fn core::clone::impls::{impl core::clone::Clone for u8#6}::clone<'_0>(@1: &'_0 (u8)) -> u8

impl core::clone::impls::{impl core::clone::Clone for u8#6} : core::clone::Clone<u8>
{
    fn clone = core::clone::impls::{impl core::clone::Clone for u8#6}::clone
}

fn core::cmp::impls::{impl core::cmp::PartialEq<bool> for bool#19}::eq<'_0, '_1>(@1: &'_0 (bool), @2: &'_1 (bool)) -> bool

fn core::cmp::impls::{impl core::cmp::PartialEq<bool> for bool#19}::ne<'_0, '_1>(@1: &'_0 (bool), @2: &'_1 (bool)) -> bool

impl core::cmp::impls::{impl core::cmp::PartialEq<bool> for bool#19} : core::cmp::PartialEq<bool, bool>
{
    fn eq = core::cmp::impls::{impl core::cmp::PartialEq<bool> for bool#19}::eq
    fn ne = core::cmp::impls::{impl core::cmp::PartialEq<bool> for bool#19}::ne
}

fn test_crate::main()
{
    let @0: (); // return
    let _x@1: (u8, bool); // local
    let _y@2: test_crate::Struct<bool>; // local
    let @3: (); // anonymous local
    let @4: (); // anonymous local

    _x@1 := (const (0 : u8), const (false))
    @fake_read(_x@1)
    _y@2 := test_crate::{impl core::default::Default for test_crate::Struct<A>#1}::default<bool>[core::default::{impl core::default::Default for bool#1}]()
    @fake_read(_y@2)
    @3 := test_crate::{impl test_crate::Trait<B> for test_crate::Struct<A>}::method<u8, bool, alloc::string::String>[core::clone::impls::{impl core::clone::Clone for u8#6}, core::cmp::impls::{impl core::cmp::PartialEq<bool> for bool#19}]()
    drop @3
    @4 := ()
    @0 := move (@4)
    drop _y@2
    drop _x@1
    @0 := ()
    return
}

fn test_crate::Trait::method<Self, B, C>()

fn core::clone::Clone::clone<'_0, Self>(@1: &'_0 (Self)) -> Self

fn core::cmp::PartialEq::eq<'_0, '_1, Self, Rhs>(@1: &'_0 (Self), @2: &'_1 (Rhs)) -> bool



